package edu.iastate.cs228.hw3;

import java.io.FileNotFoundException;
import java.util.Scanner;
import java.io.File;

/**
 *  
 * @author Shivkarthi Sundar
 *
 */

/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State> {
	public int[][] board; 
	public State previous;
	public State next;
	public State predecessor; 
	public Move move;
	public int numMoves;
	public static Heuristic heu; 
	private int numMismatchedTiles = -1;
	private int ManhattanDistance = -1;
	private int[][] goalState = new int[3][3];
	
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
	public State(int[][] board) throws IllegalArgumentException {
		this.board = board;
		previous = null;
		next = null;
		predecessor = null;
		move = null;
		numMoves = 0;
		goalState[0][0] = 1;
		goalState[0][1] = 2;
		goalState[0][2] = 3;
		goalState[1][0] = 8;
		goalState[1][1] = 0;
		goalState[1][2] = 4;
		goalState[2][0] = 7;
		goalState[2][1] = 6;
		goalState[2][2] = 5;
	}


	/**
	 * Constructor (for the initial state) 
	 * 
	 * It takes a state from an input file that has three rows, each containing three digits 
	 * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
	 * from 0 to 8 with no duplicates.  
	 * 
	 * Do the same initializations as for the first constructor. 
	 * 
	 * @param inputFileName
	 * @throws FileNotFoundException
	 * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
	 */
	public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException {
		Scanner scan = new Scanner(new File(inputFileName));
		int[][] board = new int[3][3];
		int row = 0;
		while (scan.hasNextLine()) {
			Scanner scanTwo = new Scanner(scan.nextLine());
			for (int x = 0; x < 3; x++) {
				board[row][x] = scanTwo.next().toCharArray()[0] - '0';
			}

			scanTwo.close();
			row++;
		}

		scan.close();
		boolean[] numbers = new boolean[9];
		for (int num = 0; num < 9; num++) {
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					if (num == board[x][y]) {
						numbers[num] = true;
					}
				}
			}
		}

		for (boolean b : numbers) {
			if (b != true) {
				throw new IllegalArgumentException();
			}
		}

		this.board = board;
		previous = null;
		next = null;
		predecessor = null;
		move = null;
		numMoves = 0;
		goalState[0][0] = 1;
		goalState[0][1] = 2;
		goalState[0][2] = 3;
		goalState[1][0] = 8;
		goalState[1][1] = 0;
		goalState[1][2] = 4;
		goalState[2][0] = 7;
		goalState[2][1] = 6;
		goalState[2][2] = 5;
	}


	/**
	 * Generate the successor state resulting from a given move.  Throw an exception if the move 
	 * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
	 * following:
	 * 
	 *     a) set the predecessor of the successor state to this state;
	 *     b) set the private instance variable move of the successor state to the parameter m; 
	 *     c) Set the links next and previous to null;  
	 *     d) Update numMoves. 
	 * 
	 * @param m  one of the moves LEFT, RIGHT, UP, and DOWN
	 * @return
	 * @throws IllegalArgumentException if RIGHT when the empty square is in the left column, or 
	 *                                  if LEFT when the empty square is in the right column, or 
	 *                                  if UP when the empty square is in the bottom row, or 
	 *                                  if DOWN when the empty square is in the top row. 
	 */                                  
	public State successorState(Move m) throws IllegalArgumentException {
		int[] test = search(0, 0);
		if (m == Move.UP) {
			if (test[0] == 2) {
				throw new IllegalArgumentException();
			}
		}

		if (m == Move.DOWN) {
			if (test[0] == 0) {
				throw new IllegalArgumentException();
			}
		}

		if (m == Move.RIGHT) {
			if (test[1] == 2) {
				throw new IllegalArgumentException();
			}
		}

		if (m == Move.LEFT) {
			if (test[1] == 0) {
				throw new IllegalArgumentException();
			}
		}

		State s = (State) this.clone();
		if (m == Move.UP) {
			int x = s.board[test[0] + 1][test[1]];
			s.board[test[0] + 1][test[1]] = s.board[test[0]][test[1]];
			s.board[test[0]][test[1]] = x;
		}

		if (m == Move.DOWN) {
			int x = s.board[test[0] - 1][test[1]];
			s.board[test[0] - 1][test[1]] = 0;
			s.board[test[0]][test[1]] = x;
		}

		if (m == Move.RIGHT) {
			int x = s.board[test[0]][test[1] + 1];
			s.board[test[0]][test[1] + 1] = 0;
			s.board[test[0]][test[1]] = x;
		}

		if (m == Move.LEFT) {
			int x = s.board[test[0]][test[1] - 1];
			s.board[test[0]][test[1] - 1] = 0;
			s.board[test[0]][test[1]] = x;
		}

		s.numMoves = numMoves + 1;
		s.predecessor = this;
		s.move = m;
		return s;
	}

	/**
	 * Determines the location of a given tile in the board
	 * @param i
	 * 	value of the board that is being searched for
	 * @param boardNum
	 * 	0 if searching through current state and 1 if searching through goal state
	 * @return
	 * 	int[] with first value as row and second value as column of the integer
	 */
	private int[] search(int i, int boardNum) {
		int[] location = new int[2];
		if (boardNum == 0) { 
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					if (board[x][y] == i) {
						location[0] = x;
						location[1] = y;
						return location;
					}
				}
			}
		}

		else {
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					if (goalState[x][y] == i) {
						location[0] = x;
						location[1] = y;
						return location;
					}
				}
			}
		}

		return null;
	}
	/**
	 * Determines if the board configuration in this state can be rearranged into the goal configuration. 
	 * According to the appendix in the project description, we check if this state has an odd number of 
	 * inversions. 
	 */

	/**
	 * @return true if the puzzle starting in this state can be rearranged into the goal state.
	 */
	public boolean solvable() {
		int inversions = 0;
		for (int x = 1; x < 9; x++) {
			int[] test = search(x, 0);
			for (int row = 0; row < test[0] + 1; row++) {
				for (int col = 0; col < 3; col++) {
					if (row == test[0] && col >= test[1]) {
						
					}
					
					else if (board[test[0]][test[1]] < board[row][col]) {
						inversions++;
					}
				}
			}
		}

		if (inversions%2 == 0) {
			return false;
		}

		else {
			return true;
		}
	}


	/**
	 * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
	 * 
	 * 		1 2 3 
	 * 		8 0 4 
	 * 		7 6 5 
	 * 
	 * @return
	 */
	public boolean isGoalState() {
		if (this.computeNumMismatchedTiles() == 0) {
			return true;
		}

		return false;
	}


	/**
	 * Write the board configuration according to the following format:
	 * 
	 *     a) Output row by row in three lines with no indentations.  
	 *     b) Two adjacent tiles in each row have exactly one blank in between. 
	 *     c) The empty square is represented by a blank.  
	 *     
	 * For example, 
	 * 
	 * 2   3
	 * 1 8 4
	 * 7 6 5  
	 * 
	 */
	@Override 
	public String toString() {
		String s = "";
		for (int[] row : board) {
			for (int x : row) {
				if (x == 0) {
					s += "  ";
				}

				else {
					s += x;
					s += " ";
				}
			}

			s += '\n';
		}

		return s;
	}


	/**
	 * Create a clone of this State object by copying over the board[][]. Set the links previous,
	 * next, and predecessor to null. 
	 * 
	 * The method is called by SuccessorState(); 
	 */
	@Override
	public Object clone() {
		int[][] newBoard = new int[3][3];
		for (int x = 0; x < 3; x++) {
			for (int y = 0; y < 3; y++) {
				newBoard[x][y] = board[x][y];
			}
		}

		State s = new State(newBoard);
		return (State) s;
	}


	/**
	 * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
	 * have the same content.
	 */
	@Override 
	public boolean equals(Object o) {
		if (o.getClass() != this.getClass() || o.getClass() == null) {
			return false;
		}

		for (int x = 0; x < 2; x++) {
			for (int y = 0; y < 2; y++) {
				if (((State) o).board[x][y] != board[x][y]) {
					return false;
				}
			}
		}

		return true;
	}


	/**
	 * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
	 * the estimated number of moves to the goal state using the heuristic stored in the instance 
	 * variable heu. 
	 * 
	 * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
	 * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
	 * 
	 * @return estimated number of moves from the initial state to the goal state via this state.
	 * @throws IllegalArgumentException if heuristic is neither 0 nor 1. 
	 */
	public int cost() throws IllegalArgumentException {
		if (heu == Heuristic.ManhattanDist) {
			return numMoves + computeManhattanDistance();
		}

		else if (heu == Heuristic.TileMismatch) {
			return numMoves + computeNumMismatchedTiles();
		}

		else {
			throw new IllegalArgumentException();
		}
	}


	/**
	 * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
	 * 
	 * @return -1 if c1 < c2 
	 *          0 if c1 = c2 
	 *          1 if c1 > c2 
	 *          
	 * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
	 */
	@Override
	public int compareTo(State s) {
		if (this.cost() < s.cost()) {
			return -1;
		}

		else if (this.cost() > s.cost()) {
			return 1;
		}

		else {
			return 0;
		}
	}


	/**
	 * Return the value of numMismatchedTiles if it is non-negative, and compute the value otherwise. 
	 * 
	 * @return number of mismatched tiles between this state and the goal state. 
	 */
	private int computeNumMismatchedTiles() {
		if (numMismatchedTiles < 0) {
			int mismatch = 0;
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					if (board[x][y] == 0) {
						
					}
					
					else if (board[x][y] != goalState[x][y]) {
						mismatch++;
					}
				}
			}

			return mismatch;
		}

		return numMismatchedTiles;
	}


	/**
	 * Return the value of ManhattanDistance if it is non-negative, and compute the value otherwise.
	 * @return Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance() {
		if (ManhattanDistance > -1) {
			return ManhattanDistance;
		}

		int manhattan = 0;
		for (int x = 1; x < 9; x++) {
			manhattan += Math.abs(search(x, 1)[0] - search(x, 0)[0]) + Math.abs(search(x, 1)[1] - search(x, 0)[1]);
		}

		return manhattan;
	}
}